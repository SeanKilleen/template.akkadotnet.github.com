---
layout: default
---

      <p>The previous section describes how actor paths are used to enable location transparency. This special feature deserves some extra explanation, because the related term “transparent remoting” was used quite differently in the context of programming languages, platforms and technologies.</p>

<h2>
<a name="user-content-distributed-by-default" class="anchor" href="#distributed-by-default" aria-hidden="true"><span class="octicon octicon-link"></span></a>Distributed by Default</h2>

<p>Everything in Akka is designed to work in a distributed setting: all interactions of actors use purely message passing and everything is asynchronous. This effort has been undertaken to ensure that all functions are available equally when running within a single JVM or on a cluster of hundreds of machines. The key for enabling this is to go from remote to local by way of optimization instead of trying to go from local to remote by way of generalization. See this classic paper for a detailed discussion on why the second approach is bound to fail.</p>

<h2>
<a name="user-content-ways-in-which-transparency-is-broken" class="anchor" href="#ways-in-which-transparency-is-broken" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ways in which Transparency is Broken</h2>

<p>What is true of Akka need not be true of the application which uses it, since designing for distributed execution poses some restrictions on what is possible. The most obvious one is that all messages sent over the wire must be serializable. While being a little less obvious this includes closures which are used as actor factories (i.e. within Props) if the actor is to be created on a remote node.</p>

<p>Another consequence is that everything needs to be aware of all interactions being fully asynchronous, which in a computer network might mean that it may take several minutes for a message to reach its recipient (depending on configuration). It also means that the probability for a message to be lost is much higher than within one CLR, where it is close to zero (still: no hard guarantee!).</p>

<h2>
<a name="user-content-how-is-remoting-used" class="anchor" href="#how-is-remoting-used" aria-hidden="true"><span class="octicon octicon-link"></span></a>How is Remoting Used?</h2>

<p>We took the idea of transparency to the limit in that there is nearly no API for the remoting layer of Akka: it is purely driven by configuration. Just write your application according to the principles outlined in the previous sections, then specify remote deployment of actor sub-trees in the configuration file. This way, your application can be scaled out without having to touch the code. The only piece of the API which allows programmatic influence on remote deployment is that Props contain a field which may be set to a specific Deploy instance; this has the same effect as putting an equivalent deployment into the configuration file (if both are given, configuration file wins).</p>

<h2>
<a name="user-content-peer-to-peer-vs-client-server" class="anchor" href="#peer-to-peer-vs-client-server" aria-hidden="true"><span class="octicon octicon-link"></span></a>Peer-to-Peer vs. Client-Server</h2>

<p>Akka Remoting is a communication module for connecting actor systems in a peer-to-peer fashion, and it is the foundation for Akka Clustering. The design of remoting is driven by two (related) design decisions:</p>

<ol class="task-list">
<li>Communication between involved systems is symmetric: if a system A can connect to a system B then system B must also be able to connect to system A independently.</li>
<li>The role of the communicating systems are symmetric in regards to connection patterns: there is no system that only accepts connections, and there is no system that only initiates connections.
The consequence of these decisions is that it is not possible to safely create pure client-server setups with predefined roles (violates assumption 2) and using setups involving Network Address Translation or Load Balancers (violates assumption 1).</li>
</ol><p>For client-server setups it is better to use HTTP or Akka I/O(Not yet ported to Akka.NET)</p>

<h2>
<a name="user-content-marking-points-for-scaling-up-with-routers" class="anchor" href="#marking-points-for-scaling-up-with-routers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Marking Points for Scaling Up with Routers</h2>

<p>In addition to being able to run different parts of an actor system on different nodes of a cluster, it is also possible to scale up onto more cores by multiplying actor sub-trees which support parallelization (think for example a search engine processing different queries in parallel). The clones can then be routed to in different fashions, e.g. round-robin. The only thing necessary to achieve this is that the developer needs to declare a certain actor as <code>“WithRouter”</code>, then—in its stead—a router actor will be created which will spawn up a configurable number of children of the desired type and route to them in the configured fashion. Once such a router has been declared, its configuration can be freely overridden from the configuration file, including mixing it with the remote deployment of (some of) the children. Read more about this in <a class="internal present" href="Routing">Routing</a></p>

<h2>
<a name="user-content-using-remoting" class="anchor" href="#using-remoting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using Remoting</h2>

<h4>
<a name="user-content-server" class="anchor" href="#server" aria-hidden="true"><span class="octicon octicon-link"></span></a>Server:</h4>

<div class="highlight highlight-csharp"><pre><span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="n">ConfigurationFactory</span><span class="p">.</span><span class="n">ParseString</span><span class="p">(</span><span class="s">@"</span>
<span class="s">akka {</span>
<span class="s">    actor {</span>
<span class="s">        provider = ""Akka.Remote.RemoteActorRefProvider, Akka.Remote""</span>
<span class="s">    }</span>

<span class="s">    remote {</span>
<span class="s">        helios.tcp {</span>
<span class="s">            port = 8080</span>
<span class="s">            hostname = localhost</span>
<span class="s">        }</span>
<span class="s">    }</span>
<span class="s">}</span>
<span class="s">"</span><span class="p">);</span>

<span class="k">using</span> <span class="p">(</span><span class="n">ActorSystem</span> <span class="n">system</span> <span class="p">=</span> <span class="n">ActorSystem</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="s">"MyServer"</span><span class="p">,</span> <span class="n">config</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">system</span><span class="p">.</span><span class="n">ActorOf</span><span class="p">&lt;</span><span class="n">GreetingActor</span><span class="p">&gt;(</span><span class="s">"greeter"</span><span class="p">);</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
<span class="p">}</span>

</pre></div>

<h4>
<a name="user-content-client" class="anchor" href="#client" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client:</h4>

<div class="highlight highlight-csharp"><pre><span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="n">ConfigurationFactory</span><span class="p">.</span><span class="n">ParseString</span><span class="p">(</span><span class="s">@"</span>
<span class="s">akka {</span>
<span class="s">    actor {</span>
<span class="s">        provider = ""Akka.Remote.RemoteActorRefProvider, Akka.Remote""</span>
<span class="s">    }</span>
<span class="s">    remote {</span>
<span class="s">        helios.tcp {</span>
<span class="s">            port = 8090</span>
<span class="s">            hostname = localhost</span>
<span class="s">        }</span>
<span class="s">    }</span>
<span class="s">} </span>
<span class="s">"</span><span class="p">);</span>

<span class="n">using</span><span class="p">(</span><span class="kt">var</span> <span class="n">system</span> <span class="p">=</span> <span class="n">ActorSystem</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="s">"MyClient"</span><span class="p">,</span> <span class="n">config</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">//get a reference to the remote actor</span>
    <span class="kt">var</span> <span class="n">greeter</span> <span class="p">=</span> <span class="n">system</span>
        <span class="p">.</span><span class="n">ActorSelection</span><span class="p">(</span><span class="s">"akka.tcp://MyServer@localhost:8080/user/greeter"</span><span class="p">);</span>    
    <span class="c1">//send a message to the remote actor</span>
    <span class="n">greeter</span><span class="p">.</span><span class="n">Tell</span><span class="p">(</span><span class="k">new</span> <span class="n">Greet</span> <span class="p">{</span> <span class="n">Who</span> <span class="p">=</span> <span class="s">"Roger"</span> <span class="p">});</span>

    <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
    