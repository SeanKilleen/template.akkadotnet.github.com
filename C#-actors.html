
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <!--
         The FAKE - F# Make - A DSL for build tasks
    parameters will be replaced with the
         document title extracted from the <h1> element or
         file name, if there is no <h1> heading
       -->
    <title>
        Akka.NET
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Akka.NET">
    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="content/style.css" />
    <script src="content/tips.js" type="text/javascript"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
    <div class="container">
        <div class="masthead">
            <ul class="nav nav-pills pull-right">
                <li><a href="https://github.com/akkadotnet/">github page</a></li>
            </ul>
            <h3 class="muted">Akka.NET</h3>
        </div>
        <hr />
        <div class="row">
            <div class="span9" id="main">
                <div class="google">
                    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
                    <script type="text/javascript">
    google.load('search', '1', { language: 'en', style: google.loader.themes.MINIMALIST });
    google.setOnLoadCallback(function () {
        var customSearchOptions = {}; var customSearchControl = new google.search.CustomSearchControl(
        '008890940075640760838:lcpey0sxwhg', customSearchOptions);
        customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
        customSearchControl.draw('cse');
        var path = window.location.pathname.split('/').slice(0, 4);
        if (window.location.hostname && path.length >= 4) {
            var site = "site:" + window.location.hostname + path.join('/').toString();
            customSearchControl.setSearchStartingCallback(this, function (c, s, q) { s.setQueryAddition(site); });
        }
    }, true);
                    </script>
                    <style type="text/css">
                        .gsc-control-cse {
                            font-family: Arial, sans-serif;
                            border-color: rgb(242, 242, 235);
                            background-color: rgb(242, 242, 235);
                        }

                            .gsc-control-cse .gsc-table-result {
                                font-family: Arial, sans-serif;
                                display: block;
                            }

                        input.gsc-input {
                            border-color: #BBBBBB;
                        }

                        input.gsc-search-button {
                            border-color: rgb(34, 57, 64);
                            background-color: rgb(68, 114, 129);
                            color: #FFFFFF;
                        }

                        .gsc-tabHeader.gsc-tabhInactive {
                            border-color: #777777;
                            background-color: #777777;
                        }

                        .gsc-tabHeader.gsc-tabhActive {
                            border-color: #333333;
                            background-color: #333333;
                        }

                        .gsc-tabsArea {
                            border-color: #333333;
                        }

                        .gsc-webResult.gsc-result,
                        .gsc-results .gsc-imageResult {
                            border-color: #666666;
                            background-color: #FFFFFF;
                            padding: 0.5em 0.5em;
                        }

                            .gsc-webResult.gsc-result:hover,
                            .gsc-imageResult:hover {
                                border-color: #AAAAAA;
                                background-color: #FFFFFF;
                                padding: 0.5em 0.5em;
                            }

                            .gsc-webResult.gsc-result.gsc-promotion:hover {
                                border-color: #AAAAAA;
                                background-color: #FFFFFF;
                            }

                        .gs-webResult.gs-result a.gs-title:link,
                        .gs-webResult.gs-result a.gs-title:link b,
                        .gs-imageResult a.gs-title:link,
                        .gs-imageResult a.gs-title:link b {
                            color: #444444;
                        }

                        .gs-webResult.gs-result a.gs-title:visited,
                        .gs-webResult.gs-result a.gs-title:visited b,
                        .gs-imageResult a.gs-title:visited,
                        .gs-imageResult a.gs-title:visited b {
                            color: #444444;
                        }

                        .gs-webResult.gs-result a.gs-title:hover,
                        .gs-webResult.gs-result a.gs-title:hover b,
                        .gs-imageResult a.gs-title:hover,
                        .gs-imageResult a.gs-title:hover b {
                            color: #444444;
                        }

                        .gs-webResult.gs-result a.gs-title:active,
                        .gs-webResult.gs-result a.gs-title:active b,
                        .gs-imageResult a.gs-title:active,
                        .gs-imageResult a.gs-title:active b {
                            color: #777777;
                        }

                        .gsc-cursor-page {
                            color: #444444;
                        }

                        a.gsc-trailing-more-results:link {
                            color: #444444;
                        }

                        .gs-webResult .gs-snippet,
                        .gs-imageResult .gs-snippet,
                        .gs-fileFormatType {
                            color: #333333;
                        }

                        .gs-webResult div.gs-visibleUrl,
                        .gs-imageResult div.gs-visibleUrl {
                            color: #000000;
                        }

                        .gs-webResult div.gs-visibleUrl-short {
                            color: #000000;
                        }

                        .gs-webResult div.gs-visibleUrl-short {
                            display: none;
                        }

                        .gs-webResult div.gs-visibleUrl-long {
                            display: block;
                        }

                        .gs-promotion div.gs-visibleUrl-short {
                            display: none;
                        }

                        .gs-promotion div.gs-visibleUrl-long {
                            display: block;
                        }

                        .gsc-cursor-box {
                            border-color: #FFFFFF;
                        }

                        .gsc-results .gsc-cursor-box .gsc-cursor-page {
                            border-color: #777777;
                            background-color: #FFFFFF;
                            color: #444444;
                        }

                        .gsc-results .gsc-cursor-box .gsc-cursor-current-page {
                            border-color: #333333;
                            background-color: #333333;
                            color: #444444;
                        }

                        .gsc-webResult.gsc-result.gsc-promotion {
                            border-color: #CCCCCC;
                            background-color: #E6E6E6;
                        }

                        .gsc-completion-title {
                            color: #444444;
                        }

                        .gsc-completion-snippet {
                            color: #333333;
                        }

                        .gs-promotion a.gs-title:link,
                        .gs-promotion a.gs-title:link *,
                        .gs-promotion .gs-snippet a:link {
                            color: #0000CC;
                        }

                        .gs-promotion a.gs-title:visited,
                        .gs-promotion a.gs-title:visited *,
                        .gs-promotion .gs-snippet a:visited {
                            color: #0000CC;
                        }

                        .gs-promotion a.gs-title:hover,
                        .gs-promotion a.gs-title:hover *,
                        .gs-promotion .gs-snippet a:hover {
                            color: #444444;
                        }

                        .gs-promotion a.gs-title:active,
                        .gs-promotion a.gs-title:active *,
                        .gs-promotion .gs-snippet a:active {
                            color: #00CC00;
                        }

                        .gs-promotion .gs-snippet,
                        .gs-promotion .gs-title .gs-promotion-title-right,
                        .gs-promotion .gs-title .gs-promotion-title-right * {
                            color: #333333;
                        }

                        .gs-promotion .gs-visibleUrl,
                        .gs-promotion .gs-visibleUrl-short {
                            color: #00CC00;
                        }
                    </style>


                </div>
                
      <p>The Actor Model provides a higher level of abstraction for writing concurrent and distributed systems. It alleviates the developer from having to deal with explicit locking and thread management, making it easier to write correct concurrent and parallel systems. Actors were defined in the 1973 paper by Carl Hewitt but have been popularized by the Erlang language, and used for example at Ericsson with great success to build highly concurrent and reliable telecom systems.</p>

<h2>
<a name="user-content-creating-actors" class="anchor" href="#creating-actors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating Actors</h2>

<blockquote>
<p><strong>Note</strong><br>
Since Akka.NET enforces parental supervision every actor is supervised and (potentially) the supervisor of its children, it is advisable that you familiarize yourself with <a href="Actor%20Systems">Actor Systems</a> and <a href="Supervision">Supervision and Monitoring</a> and it may also help to read <a href="Addressing">Actor References, Paths and Addresses</a>.</p>
</blockquote>

<h3>
<a name="user-content-defining-an-actor-class" class="anchor" href="#defining-an-actor-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>Defining an Actor class</h3>

<p>Actors in C# are implemented by extending the <code>ReceiveActor</code> class and configuring what messages to receive using the <code>Receive&lt;TMessage&gt;</code> method.</p>

<p>Here is an example:</p>

<div class="highlight highlight-csharp"><pre><span class="k">using</span> <span class="nn">Akka</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Akka.Actor</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Akka.Event</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MyActor</span><span class="p">:</span> <span class="n">ReceiveActor</span>
<span class="p">{</span>
  <span class="n">LoggingAdapter</span> <span class="n">log</span> <span class="p">=</span> <span class="n">Logging</span><span class="p">.</span><span class="n">GetLogger</span><span class="p">(</span><span class="n">Context</span><span class="p">);</span>

  <span class="k">public</span> <span class="nf">MyActor</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">Receive</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="n">message</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="n">log</span><span class="p">.</span><span class="n">Info</span><span class="p">(</span><span class="s">"Received String message: {0}"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
      <span class="n">Sender</span><span class="p">.</span><span class="n">Tell</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="p">});</span>  
    <span class="n">Receive</span><span class="p">&lt;</span><span class="n">SomeMessage</span><span class="p">(</span><span class="n">message</span> <span class="p">=&gt;</span> <span class="p">{...});</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3>
<a name="user-content-the-inbox" class="anchor" href="#the-inbox" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Inbox</h3>

<p>When writing code outside of actors which shall communicate with actors, the ask pattern can be a solution (see below), but there are two thing it cannot do: receiving multiple replies (e.g. by subscribing an <code>ActorRef</code> to a notification service) and watching other actors’ lifecycle. For these purposes there is the Inbox class:</p>

<div class="highlight highlight-csharp"><pre><span class="n">final</span> <span class="n">Inbox</span> <span class="n">inbox</span> <span class="p">=</span> <span class="n">Inbox</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
<span class="n">inbox</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="n">assert</span> <span class="n">inbox</span><span class="p">.</span><span class="n">receive</span><span class="p">(</span><span class="n">Duration</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">TimeUnit</span><span class="p">.</span><span class="n">SECONDS</span><span class="p">)).</span><span class="k">equals</span><span class="p">(</span><span class="s">"world"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">TimeoutException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// timeout</span>
<span class="p">}</span>
</pre></div>

<p>The send method wraps a normal tell and supplies the internal actor’s reference as the sender. This allows the reply to be received on the last line. Watching an actor is quite simple as well:</p>

<div class="highlight highlight-csharp"><pre><span class="n">final</span> <span class="n">Inbox</span> <span class="n">inbox</span> <span class="p">=</span> <span class="n">Inbox</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
<span class="n">inbox</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
<span class="n">target</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">PoisonPill</span><span class="p">.</span><span class="n">getInstance</span><span class="p">(),</span> <span class="n">ActorRef</span><span class="p">.</span><span class="n">noSender</span><span class="p">());</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="n">assert</span> <span class="n">inbox</span><span class="p">.</span><span class="n">receive</span><span class="p">(</span><span class="n">Duration</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">TimeUnit</span><span class="p">.</span><span class="n">SECONDS</span><span class="p">))</span> <span class="n">instanceof</span> <span class="n">Terminated</span><span class="p">;</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">TimeoutException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// timeout</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="user-content-untypedactor-api" class="anchor" href="#untypedactor-api" aria-hidden="true"><span class="octicon octicon-link"></span></a>UntypedActor API</h2>

<p>The <code>UntypedActor</code> class defines only one abstract method, the above mentioned <code>OnReceive(object message)</code>, which implements the behavior of the actor.</p>

<p>If the current actor behavior does not match a received message, it's recommended that you call the unhandled method, which by default publishes a new <code>Akka.Actor.UnhandledMessage(message, sender, recipient)</code> on the actor system’s event stream (set configuration item <code>akka.actor.debug.unhandled</code> to on to have them converted into actual <code>Debug</code> messages).</p>

<p>In addition, it offers:</p>

<ul class="task-list">
<li><p><code>Self</code> reference to the <code>ActorRef</code> of the actor</p></li>
<li><p><code>Sender</code> reference sender Actor of the last received message, typically used as described in Reply to messages</p></li>
<li><p>SupervisorStrategy user overridable definition the strategy to use for supervising child actors</p></li>
</ul><p>This strategy is typically declared inside the actor in order to have access to the actor’s internal state within the decider function: since failure is communicated as a message sent to the supervisor and processed like other messages (albeit outside of the normal behavior), all values and variables within the actor are available, as is the getSender() reference (which will be the immediate child reporting the failure; if the original failure occurred within a distant descendant it is still reported one level up at a time).</p>

<ul class="task-list">
<li>
<p><code>Context</code> exposes contextual information for the actor and the current message, such as:</p>

<ul class="task-list">
<li>factory methods to create child actors (actorOf)</li>
<li>system that the actor belongs to</li>
<li>parent supervisor</li>
<li>supervised children</li>
<li>lifecycle monitoring</li>
<li>hotswap behavior stack as described in HotSwap</li>
</ul>
</li>
</ul><p>The remaining visible methods are user-overridable life-cycle hooks which are described in the following:</p>

<div class="highlight highlight-csharp"><pre><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">PreStart</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">PreRestart</span><span class="p">(</span><span class="n">Throwable</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">object</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">ActorRef</span> <span class="n">each</span> <span class="p">:</span> <span class="n">getContext</span><span class="p">().</span><span class="n">getChildren</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">getContext</span><span class="p">().</span><span class="n">unwatch</span><span class="p">(</span><span class="n">each</span><span class="p">);</span>
    <span class="n">getContext</span><span class="p">().</span><span class="n">stop</span><span class="p">(</span><span class="n">each</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">postStop</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">postRestart</span><span class="p">(</span><span class="n">Throwable</span> <span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">preStart</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">postStop</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>

<p>The implementations shown above are the defaults provided by the UntypedActor class.</p>

<h2>
<a name="user-content-identifying-actors-via-actor-selection" class="anchor" href="#identifying-actors-via-actor-selection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Identifying Actors via Actor Selection</h2>

<p>As described in Actor References, Paths and Addresses, each actor has a unique logical path, which is obtained by following the chain of actors from child to parent until reaching the root of the actor system, and it has a physical path, which may differ if the supervision chain includes any remote supervisors. These paths are used by the system to look up actors, e.g. when a remote message is received and the recipient is searched, but they are also useful more directly: actors may look up other actors by specifying absolute or relative paths—logical or physical—and receive back an ActorSelection with the result:</p>

<div class="highlight highlight-csharp"><pre><span class="c1">// will look up this absolute path</span>
<span class="n">getContext</span><span class="p">().</span><span class="n">actorSelection</span><span class="p">(</span><span class="s">"/user/serviceA/actor"</span><span class="p">);</span>
<span class="c1">// will look up sibling beneath same supervisor</span>
<span class="n">getContext</span><span class="p">().</span><span class="n">actorSelection</span><span class="p">(</span><span class="s">"../joe"</span><span class="p">);</span>
</pre></div>

<p>The supplied path is parsed as a java.net.URI, which basically means that it is split on / into path elements. If the path starts with /, it is absolute and the look-up starts at the root guardian (which is the parent of "/user"); otherwise it starts at the current actor. If a path element equals .., the look-up will take a step “up” towards the supervisor of the currently traversed actor, otherwise it will step “down” to the named child. It should be noted that the .. in actor paths here always means the logical structure, i.e. the supervisor.</p>

<p>The path elements of an actor selection may contain wildcard patterns allowing for broadcasting of messages to that section:</p>

<div class="highlight highlight-csharp"><pre><span class="c1">// will look all children to serviceB with names starting with worker</span>
<span class="n">getContext</span><span class="p">().</span><span class="n">actorSelection</span><span class="p">(</span><span class="s">"/user/serviceB/worker*"</span><span class="p">);</span>
<span class="c1">// will look up all siblings beneath same supervisor</span>
<span class="n">getContext</span><span class="p">().</span><span class="n">actorSelection</span><span class="p">(</span><span class="s">"../*"</span><span class="p">);</span>
</pre></div>

<p>Messages can be sent via the ActorSelection and the path of the ActorSelection is looked up when delivering each message. If the selection does not match any actors the message will be dropped.</p>

<p>To acquire an ActorRef for an ActorSelection you need to send a message to the selection and use the getSender reference of the reply from the actor. There is a built-in Identify message that all Actors will understand and automatically reply to with a ActorIdentity message containing the ActorRef. This message is handled specially by the actors which are traversed in the sense that if a concrete name lookup fails (i.e. a non-wildcard path element does not correspond to a live actor) then a negative result is generated. Please note that this does not mean that delivery of that reply is guaranteed, it still is a normal message.</p>

<div class="highlight highlight-csharp"><pre><span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="n">actor</span><span class="p">.</span><span class="n">ActorIdentity</span><span class="p">;</span>
<span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="n">actor</span><span class="p">.</span><span class="n">ActorSelection</span><span class="p">;</span>
<span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="n">actor</span><span class="p">.</span><span class="n">Identify</span><span class="p">;</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Follower</span> <span class="n">extends</span> <span class="n">UntypedActor</span> <span class="p">{</span>
  <span class="n">final</span> <span class="n">String</span> <span class="n">identifyId</span> <span class="p">=</span> <span class="s">"1"</span><span class="p">;</span>
  <span class="p">{</span>
    <span class="n">ActorSelection</span> <span class="n">selection</span> <span class="p">=</span>
      <span class="n">getContext</span><span class="p">().</span><span class="n">actorSelection</span><span class="p">(</span><span class="s">"/user/another"</span><span class="p">);</span>
    <span class="n">selection</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="k">new</span> <span class="n">Identify</span><span class="p">(</span><span class="n">identifyId</span><span class="p">),</span> <span class="n">getSelf</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="n">ActorRef</span> <span class="n">another</span><span class="p">;</span>

  <span class="n">final</span> <span class="n">ActorRef</span> <span class="n">probe</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">Follower</span><span class="p">(</span><span class="n">ActorRef</span> <span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">probe</span> <span class="p">=</span> <span class="n">probe</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">@Override</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">onReceive</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">message</span> <span class="n">instanceof</span> <span class="n">ActorIdentity</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ActorIdentity</span> <span class="n">identity</span> <span class="p">=</span> <span class="p">(</span><span class="n">ActorIdentity</span><span class="p">)</span> <span class="n">message</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">identity</span><span class="p">.</span><span class="n">correlationId</span><span class="p">().</span><span class="k">equals</span><span class="p">(</span><span class="n">identifyId</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ActorRef</span> <span class="k">ref</span> <span class="p">=</span> <span class="n">identity</span><span class="p">.</span><span class="n">getRef</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">ref</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
          <span class="n">getContext</span><span class="p">().</span><span class="n">stop</span><span class="p">(</span><span class="n">getSelf</span><span class="p">());</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="n">another</span> <span class="p">=</span> <span class="k">ref</span><span class="p">;</span>
          <span class="n">getContext</span><span class="p">().</span><span class="n">watch</span><span class="p">(</span><span class="n">another</span><span class="p">);</span>
          <span class="n">probe</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="k">ref</span><span class="p">,</span> <span class="n">getSelf</span><span class="p">());</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">message</span> <span class="n">instanceof</span> <span class="n">Terminated</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">final</span> <span class="n">Terminated</span> <span class="n">t</span> <span class="p">=</span> <span class="p">(</span><span class="n">Terminated</span><span class="p">)</span> <span class="n">message</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">getActor</span><span class="p">().</span><span class="k">equals</span><span class="p">(</span><span class="n">another</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">getContext</span><span class="p">().</span><span class="n">stop</span><span class="p">(</span><span class="n">getSelf</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">unhandled</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>You can also acquire an ActorRef for an ActorSelection with the resolveOne method of the ActorSelection. It returns a Future of the matching ActorRef if such an actor exists. It is completed with failure <a class="internal absent" href="akka.actor.ActorNotFound">akka.actor.ActorNotFound</a> if no such actor exists or the identification didn't complete within the supplied timeout.</p>

<p>Remote actor addresses may also be looked up, if remoting is enabled:</p>

<div class="highlight highlight-csharp"><pre><span class="n">getContext</span><span class="p">().</span><span class="n">actorSelection</span><span class="p">(</span><span class="s">"akka.tcp://app@otherhost:1234/user/serviceB"</span><span class="p">);</span>
</pre></div>

<p>An example demonstrating remote actor look-up is given in Remoting Sample.</p>

<blockquote>
<p><strong>Note</strong><br>
actorFor is deprecated in favor of actorSelection because actor references acquired with actorFor behave differently for local and remote actors. In the case of a local actor reference, the named actor needs to exist before the lookup, or else the acquired reference will be an EmptyLocalActorRef. This will be true even if an actor with that exact path is created after acquiring the actor reference. For remote actor references acquired with actorFor the behaviour is different and sending messages to such a reference will under the hood look up the actor by path on the remote system for every message send.</p>
</blockquote>

<h2>
<a name="user-content-messages-and-immutability" class="anchor" href="#messages-and-immutability" aria-hidden="true"><span class="octicon octicon-link"></span></a>Messages and immutability</h2>

<p><strong>IMPORTANT:</strong> Messages can be any kind of object but have to be immutable. Akka can’t enforce immutability (yet) so this has to be by convention.</p>

<p>Here is an example of an immutable message:</p>

<div class="highlight highlight-csharp"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">ImmutableMessage</span> <span class="p">{</span>
  <span class="k">private</span> <span class="n">final</span> <span class="kt">int</span> <span class="n">sequenceNumber</span><span class="p">;</span>
  <span class="k">private</span> <span class="n">final</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="n">values</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">ImmutableMessage</span><span class="p">(</span><span class="kt">int</span> <span class="n">sequenceNumber</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">sequenceNumber</span> <span class="p">=</span> <span class="n">sequenceNumber</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">values</span> <span class="p">=</span> <span class="n">Collections</span><span class="p">.</span><span class="n">unmodifiableList</span><span class="p">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;(</span><span class="n">values</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">int</span> <span class="nf">getSequenceNumber</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">sequenceNumber</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="n">getValues</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">values</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="user-content-send-messages" class="anchor" href="#send-messages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Send messages</h2>

<p>Messages are sent to an Actor through one of the following methods.</p>

<p>tell means “fire-and-forget”, e.g. send a message asynchronously and return immediately.
ask sends a message asynchronously and returns a Future representing a possible reply.
Message ordering is guaranteed on a per-sender basis.</p>

<blockquote>
<p><strong>Note</strong><br>
There are performance implications of using ask since something needs to keep track of when it times out, there needs to be something that bridges a Promise into an ActorRef and it also needs to be reachable through remoting. So always prefer tell for performance, and only ask if you must.</p>
</blockquote>

<p>In all these methods you have the option of passing along your own ActorRef. Make it a practice of doing so because it will allow the receiver actors to be able to respond to your message, since the sender reference is sent along with the message.</p>

<h3>
<a name="user-content-tell-fire-forget" class="anchor" href="#tell-fire-forget" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tell: Fire-forget</h3>

<p>This is the preferred way of sending messages. No blocking waiting for a message. This gives the best concurrency and scalability characteristics.</p>

<div class="highlight highlight-csharp"><pre><span class="c1">// don’t forget to think about who is the sender (2nd argument)</span>
<span class="n">target</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">getSelf</span><span class="p">());</span>
</pre></div>

<p>The sender reference is passed along with the message and available within the receiving actor via its getSender method while processing this message. Inside of an actor it is usually getSelf who shall be the sender, but there can be cases where replies shall be routed to some other actor—e.g. the parent—in which the second argument to tell would be a different one. Outside of an actor and if no reply is needed the second argument can be null; if a reply is needed outside of an actor you can use the ask-pattern described next..</p>

<h3>
<a name="user-content-ask-send-and-receive-future" class="anchor" href="#ask-send-and-receive-future" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ask: Send-And-Receive-Future</h3>

<p>The ask pattern involves actors as well as futures, hence it is offered as a use pattern rather than a method on ActorRef:</p>

<div class="highlight highlight-csharp"><pre><span class="n">import</span> <span class="k">static</span> <span class="n">akka</span><span class="p">.</span><span class="n">pattern</span><span class="p">.</span><span class="n">Patterns</span><span class="p">.</span><span class="n">ask</span><span class="p">;</span>
<span class="n">import</span> <span class="k">static</span> <span class="n">akka</span><span class="p">.</span><span class="n">pattern</span><span class="p">.</span><span class="n">Patterns</span><span class="p">.</span><span class="n">pipe</span><span class="p">;</span>
<span class="n">import</span> <span class="n">scala</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">Future</span><span class="p">;</span>
<span class="n">import</span> <span class="n">scala</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">duration</span><span class="p">.</span><span class="n">Duration</span><span class="p">;</span>
<span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="n">dispatch</span><span class="p">.</span><span class="n">Futures</span><span class="p">;</span>
<span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="n">dispatch</span><span class="p">.</span><span class="n">Mapper</span><span class="p">;</span>
<span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">Timeout</span><span class="p">;</span>
<span class="n">final</span> <span class="n">Timeout</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Timeout</span><span class="p">(</span><span class="n">Duration</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="n">TimeUnit</span><span class="p">.</span><span class="n">SECONDS</span><span class="p">));</span>

<span class="n">final</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">Future</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;&gt;</span> <span class="n">futures</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">Future</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;&gt;();</span>
<span class="n">futures</span><span class="p">.</span><span class="k">add</span><span class="p">(</span><span class="n">ask</span><span class="p">(</span><span class="n">actorA</span><span class="p">,</span> <span class="s">"request"</span><span class="p">,</span> <span class="m">1000</span><span class="p">));</span> <span class="c1">// using 1000ms timeout</span>
<span class="n">futures</span><span class="p">.</span><span class="k">add</span><span class="p">(</span><span class="n">ask</span><span class="p">(</span><span class="n">actorB</span><span class="p">,</span> <span class="s">"another request"</span><span class="p">,</span> <span class="n">t</span><span class="p">));</span> <span class="c1">// using timeout from</span>
                                                <span class="c1">// above</span>

<span class="n">final</span> <span class="n">Future</span><span class="p">&lt;</span><span class="n">Iterable</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;&gt;</span> <span class="n">aggregate</span> <span class="p">=</span> <span class="n">Futures</span><span class="p">.</span><span class="n">sequence</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span>
    <span class="n">system</span><span class="p">.</span><span class="n">dispatcher</span><span class="p">());</span>

<span class="n">final</span> <span class="n">Future</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&gt;</span> <span class="n">transformed</span> <span class="p">=</span> <span class="n">aggregate</span><span class="p">.</span><span class="n">map</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">Mapper</span><span class="p">&lt;</span><span class="n">Iterable</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;,</span> <span class="n">Result</span><span class="p">&gt;()</span> <span class="p">{</span>
      <span class="k">public</span> <span class="n">Result</span> <span class="nf">apply</span><span class="p">(</span><span class="n">Iterable</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;</span> <span class="n">coll</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">final</span> <span class="n">Iterator</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;</span> <span class="n">it</span> <span class="p">=</span> <span class="n">coll</span><span class="p">.</span><span class="n">iterator</span><span class="p">();</span>
        <span class="n">final</span> <span class="n">String</span> <span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="n">String</span><span class="p">)</span> <span class="n">it</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
        <span class="n">final</span> <span class="n">String</span> <span class="n">s</span> <span class="p">=</span> <span class="p">(</span><span class="n">String</span><span class="p">)</span> <span class="n">it</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Result</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">},</span> <span class="n">system</span><span class="p">.</span><span class="n">dispatcher</span><span class="p">());</span>

<span class="n">pipe</span><span class="p">(</span><span class="n">transformed</span><span class="p">,</span> <span class="n">system</span><span class="p">.</span><span class="n">dispatcher</span><span class="p">()).</span><span class="n">to</span><span class="p">(</span><span class="n">actorC</span><span class="p">);</span>
</pre></div>

<p>This example demonstrates ask together with the pipe pattern on futures, because this is likely to be a common combination. Please note that all of the above is completely non-blocking and asynchronous: ask produces a Future, two of which are composed into a new future using the Futures.sequence and map methods and then pipe installs an onComplete-handler on the future to effect the submission of the aggregated Result to another actor.</p>

<p>Using ask will send a message to the receiving Actor as with tell, and the receiving actor must reply with getSender().tell(reply, getSelf()) in order to complete the returned Future with a value. The ask operation involves creating an internal actor for handling this reply, which needs to have a timeout after which it is destroyed in order not to leak resources; see more below.</p>

<blockquote>
<p><strong>Warning</strong><br>
To complete the future with an exception you need send a Failure message to the sender. This is not done automatically when an actor throws an exception while processing a message.</p>
</blockquote>

<div class="highlight highlight-csharp"><pre><span class="k">try</span> <span class="p">{</span>
  <span class="n">String</span> <span class="n">result</span> <span class="p">=</span> <span class="n">operation</span><span class="p">();</span>
  <span class="n">getSender</span><span class="p">().</span><span class="n">tell</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">getSelf</span><span class="p">());</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">getSender</span><span class="p">().</span><span class="n">tell</span><span class="p">(</span><span class="k">new</span> <span class="n">akka</span><span class="p">.</span><span class="n">actor</span><span class="p">.</span><span class="n">Status</span><span class="p">.</span><span class="n">Failure</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">getSelf</span><span class="p">());</span>
  <span class="k">throw</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>If the actor does not complete the future, it will expire after the timeout period, specified as parameter to the ask method; this will complete the Future with an AskTimeoutException.</p>

<p>See Futures for more information on how to await or query a future.</p>

<p>The onComplete, onSuccess, or onFailure methods of the Future can be used to register a callback to get a notification when the Future completes. Gives you a way to avoid blocking.</p>

<blockquote>
<p><strong>Warning</strong><br>
When using future callbacks, inside actors you need to carefully avoid closing over the containing actor’s reference, i.e. do not call methods or access mutable state on the enclosing actor from within the callback. This would break the actor encapsulation and may introduce synchronization bugs and race conditions because the callback will be scheduled concurrently to the enclosing actor. Unfortunately there is not yet a way to detect these illegal accesses at compile time. See also: Actors and shared mutable state</p>
</blockquote>

<h3>
<a name="user-content-forward-message" class="anchor" href="#forward-message" aria-hidden="true"><span class="octicon octicon-link"></span></a>Forward message</h3>

<p>You can forward a message from one actor to another. This means that the original sender address/reference is maintained even though the message is going through a 'mediator'. This can be useful when writing actors that work as routers, load-balancers, replicators etc. You need to pass along your context variable as well.</p>

<div class="highlight highlight-csharp"><pre><span class="n">target</span><span class="p">.</span><span class="n">forward</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">getContext</span><span class="p">());</span>
</pre></div>

<h2>
<a name="user-content-receive-messages" class="anchor" href="#receive-messages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Receive messages</h2>

<p>When an actor receives a message it is passed into the onReceive method, this is an abstract method on the UntypedActor base class that needs to be defined.</p>

<p>Here is an example:</p>

<div class="highlight highlight-csharp"><pre><span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="n">actor</span><span class="p">.</span><span class="n">UntypedActor</span><span class="p">;</span>
<span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="k">event</span><span class="p">.</span><span class="n">Logging</span><span class="p">;</span>
<span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="k">event</span><span class="p">.</span><span class="n">LoggingAdapter</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MyUntypedActor</span> <span class="n">extends</span> <span class="n">UntypedActor</span> <span class="p">{</span>
  <span class="n">LoggingAdapter</span> <span class="n">log</span> <span class="p">=</span> <span class="n">Logging</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">getContext</span><span class="p">().</span><span class="n">system</span><span class="p">(),</span> <span class="k">this</span><span class="p">);</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">onReceive</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Exception</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">message</span> <span class="n">instanceof</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Received String message: {}"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
      <span class="n">getSender</span><span class="p">().</span><span class="n">tell</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">getSelf</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span>
      <span class="n">unhandled</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>An alternative to using if-instanceof checks is to use Apache Commons MethodUtils to invoke a named method whose parameter type matches the message type.</p>

<h2>
<a name="user-content-reply-to-messages" class="anchor" href="#reply-to-messages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reply to messages</h2>

<p>If you want to have a handle for replying to a message, you can use getSender(), which gives you an ActorRef. You can reply by sending to that ActorRef with getSender().tell(replyMsg, getSelf()). You can also store the ActorRef for replying later, or passing on to other actors. If there is no sender (a message was sent without an actor or future context) then the sender defaults to a 'dead-letter' actor ref.</p>

<div class="highlight highlight-csharp"><pre><span class="n">@Override</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">onReceive</span><span class="p">(</span><span class="n">Object</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Object</span> <span class="n">result</span> <span class="p">=</span>
      <span class="c1">// calculate result ...</span>

  <span class="c1">// do not forget the second argument!</span>
  <span class="n">getSender</span><span class="p">().</span><span class="n">tell</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">getSelf</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="user-content-stopping-actors" class="anchor" href="#stopping-actors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stopping actors</h2>

<p>Actors are stopped by invoking the stop method of a ActorRefFactory, i.e. ActorContext or ActorSystem. Typically the context is used for stopping child actors and the system for stopping top level actors. The actual termination of the actor is performed asynchronously, i.e. stop may return before the actor is stopped.</p>

<p>Processing of the current message, if any, will continue before the actor is stopped, but additional messages in the mailbox will not be processed. By default these messages are sent to the deadLetters of the ActorSystem, but that depends on the mailbox implementation.</p>

<p>Termination of an actor proceeds in two steps: first the actor suspends its mailbox processing and sends a stop command to all its children, then it keeps processing the internal termination notifications from its children until the last one is gone, finally terminating itself (invoking postStop, dumping mailbox, publishing Terminated on the DeathWatch, telling its supervisor). This procedure ensures that actor system sub-trees terminate in an orderly fashion, propagating the stop command to the leaves and collecting their confirmation back to the stopped supervisor. If one of the actors does not respond (i.e. processing a message for extended periods of time and therefore not receiving the stop command), this whole process will be stuck.</p>

<p>Upon ActorSystem.shutdown, the system guardian actors will be stopped, and the aforementioned process will ensure proper termination of the whole system.</p>

<p>The postStop hook is invoked after an actor is fully stopped. This enables cleaning up of resources:</p>

<div class="highlight highlight-csharp"><pre><span class="n">@Override</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">postStop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// clean up resources here ...</span>
<span class="p">}</span>
</pre></div>

<blockquote>
<p><strong>Note</strong><br>
Since stopping an actor is asynchronous, you cannot immediately reuse the name of the child you just stopped; this will result in an InvalidActorNameException. Instead, watch the terminating actor and create its replacement in response to the Terminated message which will eventually arrive.</p>
</blockquote>

<h3>
<a name="user-content-poisonpill" class="anchor" href="#poisonpill" aria-hidden="true"><span class="octicon octicon-link"></span></a>PoisonPill</h3>

<p>You can also send an actor the akka.actor.PoisonPill message, which will stop the actor when the message is processed. PoisonPill is enqueued as ordinary messages and will be handled after messages that were already queued in the mailbox.</p>

<p>Use it like this:</p>

<div class="highlight highlight-csharp"><pre><span class="n">myActor</span><span class="p">.</span><span class="n">Tell</span><span class="p">(</span><span class="n">Akka</span><span class="p">.</span><span class="n">Actor</span><span class="p">.</span><span class="n">PoisonPill</span><span class="p">.</span><span class="n">Instance</span><span class="p">,</span> <span class="n">Sender</span><span class="p">);</span>
</pre></div>

<h3>
<a name="user-content-graceful-stop" class="anchor" href="#graceful-stop" aria-hidden="true"><span class="octicon octicon-link"></span></a>Graceful Stop</h3>

<p>gracefulStop is useful if you need to wait for termination or compose ordered termination of several actors:</p>

<div class="highlight highlight-csharp"><pre><span class="n">import</span> <span class="k">static</span> <span class="n">akka</span><span class="p">.</span><span class="n">pattern</span><span class="p">.</span><span class="n">Patterns</span><span class="p">.</span><span class="n">gracefulStop</span><span class="p">;</span>
<span class="n">import</span> <span class="n">scala</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">Await</span><span class="p">;</span>
<span class="n">import</span> <span class="n">scala</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">Future</span><span class="p">;</span>
<span class="n">import</span> <span class="n">scala</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">duration</span><span class="p">.</span><span class="n">Duration</span><span class="p">;</span>
<span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="n">pattern</span><span class="p">.</span><span class="n">AskTimeoutException</span><span class="p">;</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="n">Future</span><span class="p">&lt;</span><span class="n">Boolean</span><span class="p">&gt;</span> <span class="n">stopped</span> <span class="p">=</span>
    <span class="n">gracefulStop</span><span class="p">(</span><span class="n">actorRef</span><span class="p">,</span> <span class="n">Duration</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="n">TimeUnit</span><span class="p">.</span><span class="n">SECONDS</span><span class="p">),</span> <span class="n">Manager</span><span class="p">.</span><span class="n">SHUTDOWN</span><span class="p">);</span>
  <span class="n">Await</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="n">stopped</span><span class="p">,</span> <span class="n">Duration</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="m">6</span><span class="p">,</span> <span class="n">TimeUnit</span><span class="p">.</span><span class="n">SECONDS</span><span class="p">));</span>
  <span class="c1">// the actor has been stopped</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">AskTimeoutException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// the actor wasn't stopped within 5 seconds</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Manager</span> <span class="n">extends</span> <span class="n">UntypedActor</span> <span class="p">{</span>

  <span class="k">public</span> <span class="k">static</span> <span class="n">final</span> <span class="n">String</span> <span class="n">SHUTDOWN</span> <span class="p">=</span> <span class="s">"shutdown"</span><span class="p">;</span>

  <span class="n">ActorRef</span> <span class="n">worker</span> <span class="p">=</span> <span class="n">getContext</span><span class="p">().</span><span class="n">watch</span><span class="p">(</span><span class="n">getContext</span><span class="p">().</span><span class="n">actorOf</span><span class="p">(</span>
      <span class="n">Props</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">Cruncher</span><span class="p">.</span><span class="n">class</span><span class="p">),</span> <span class="s">"worker"</span><span class="p">));</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">onReceive</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="s">"job"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">worker</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="s">"crunch"</span><span class="p">,</span> <span class="n">getSelf</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="n">SHUTDOWN</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">worker</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">PoisonPill</span><span class="p">.</span><span class="n">getInstance</span><span class="p">(),</span> <span class="n">getSelf</span><span class="p">());</span>
      <span class="n">getContext</span><span class="p">().</span><span class="n">become</span><span class="p">(</span><span class="n">shuttingDown</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">Procedure</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;</span> <span class="n">shuttingDown</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Procedure</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;()</span> <span class="p">{</span>
    <span class="n">@Override</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">apply</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="s">"job"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">getSender</span><span class="p">().</span><span class="n">tell</span><span class="p">(</span><span class="s">"service unavailable, shutting down"</span><span class="p">,</span> <span class="n">getSelf</span><span class="p">());</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">message</span> <span class="n">instanceof</span> <span class="n">Terminated</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">getContext</span><span class="p">().</span><span class="n">stop</span><span class="p">(</span><span class="n">getSelf</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>

<p>When <code>GracefulStop()</code> returns successfully, the actor’s <code>PostStop()</code> hook will have been executed: there exists a happens-before edge between the end of postStop() and the return of gracefulStop().</p>

<p>In the above example a custom Manager.SHUTDOWN message is sent to the target actor to initiate the process of stopping the actor. You can use PoisonPill for this, but then you have limited possibilities to perform interactions with other actors before stopping the target actor. Simple cleanup tasks can be handled in postStop.</p>

<blockquote>
<p><strong>Warning</strong><br>
Keep in mind that an actor stopping and its name being deregistered are separate events which happen asynchronously from each other. Therefore it may be that you will find the name still in use after gracefulStop() returned. In order to guarantee proper deregistration, only reuse names from within a supervisor you control and only in response to a Terminated message, i.e. not for top-level actors.</p>
</blockquote>

<h2>
<a name="user-content-hotswap" class="anchor" href="#hotswap" aria-hidden="true"><span class="octicon octicon-link"></span></a>HotSwap</h2>

<h3>
<a name="user-content-upgrade" class="anchor" href="#upgrade" aria-hidden="true"><span class="octicon octicon-link"></span></a>Upgrade</h3>

<p>Akka supports hotswapping the Actor’s message loop (e.g. its implementation) at runtime. Use the getContext().become method from within the Actor. The hotswapped code is kept in a Stack which can be pushed (replacing or adding at the top) and popped.</p>

<blockquote>
<p><strong>Warning</strong><br>
Please note that the actor will revert to its original behavior when restarted by its Supervisor.</p>
</blockquote>

<p>To hotswap the Actor using <code>getContext().become</code>:</p>

<div class="highlight highlight-csharp"><pre><span class="n">import</span> <span class="n">akka</span><span class="p">.</span><span class="n">japi</span><span class="p">.</span><span class="n">Procedure</span><span class="p">;</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">HotSwapActor</span> <span class="n">extends</span> <span class="n">UntypedActor</span> <span class="p">{</span>

  <span class="n">Procedure</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;</span> <span class="n">angry</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Procedure</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;()</span> <span class="p">{</span>
    <span class="n">@Override</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">apply</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="s">"bar"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">getSender</span><span class="p">().</span><span class="n">tell</span><span class="p">(</span><span class="s">"I am already angry?"</span><span class="p">,</span> <span class="n">getSelf</span><span class="p">());</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="s">"foo"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">getContext</span><span class="p">().</span><span class="n">become</span><span class="p">(</span><span class="n">happy</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="n">Procedure</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;</span> <span class="n">happy</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Procedure</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;()</span> <span class="p">{</span>
    <span class="n">@Override</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">apply</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="s">"bar"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">getSender</span><span class="p">().</span><span class="n">tell</span><span class="p">(</span><span class="s">"I am already happy :-)"</span><span class="p">,</span> <span class="n">getSelf</span><span class="p">());</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="s">"foo"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">getContext</span><span class="p">().</span><span class="n">become</span><span class="p">(</span><span class="n">angry</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">onReceive</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="s">"bar"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">getContext</span><span class="p">().</span><span class="n">become</span><span class="p">(</span><span class="n">angry</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="s">"foo"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">getContext</span><span class="p">().</span><span class="n">become</span><span class="p">(</span><span class="n">happy</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">unhandled</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>This variant of the become method is useful for many different things, such as to implement a Finite State Machine (FSM). It will replace the current behavior (i.e. the top of the behavior stack), which means that you do not use unbecome, instead always the next behavior is explicitly installed.</p>

<p>The other way of using become does not replace but add to the top of the behavior stack. In this case care must be taken to ensure that the number of “pop” operations (i.e. unbecome) matches the number of “push” ones in the long run, otherwise this amounts to a memory leak (which is why this behavior is not the default).</p>

<div class="highlight highlight-csharp"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">UntypedActorSwapper</span> <span class="p">{</span>

  <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Swap</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">Swap</span> <span class="n">SWAP</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Swap</span><span class="p">();</span>

    <span class="k">private</span> <span class="nf">Swap</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Swapper</span> <span class="n">extends</span> <span class="n">UntypedActor</span> <span class="p">{</span>
    <span class="n">LoggingAdapter</span> <span class="n">log</span> <span class="p">=</span> <span class="n">Logging</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">getContext</span><span class="p">().</span><span class="n">system</span><span class="p">(),</span> <span class="k">this</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">onReceive</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">message</span> <span class="p">==</span> <span class="n">SWAP</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Hi"</span><span class="p">);</span>
        <span class="n">getContext</span><span class="p">().</span><span class="n">become</span><span class="p">(</span><span class="k">new</span> <span class="n">Procedure</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;()</span> <span class="p">{</span>
          <span class="n">@Override</span>
          <span class="k">public</span> <span class="k">void</span> <span class="nf">apply</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Ho"</span><span class="p">);</span>
            <span class="n">getContext</span><span class="p">().</span><span class="n">unbecome</span><span class="p">();</span> <span class="c1">// resets the latest 'become'</span>
          <span class="p">}</span>
        <span class="p">},</span> <span class="k">false</span><span class="p">);</span> <span class="c1">// this signals stacking of the new behavior</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">unhandled</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ActorSystem</span> <span class="n">system</span> <span class="p">=</span> <span class="n">ActorSystem</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="s">"MySystem"</span><span class="p">);</span>
    <span class="n">ActorRef</span> <span class="n">swap</span> <span class="p">=</span> <span class="n">system</span><span class="p">.</span><span class="n">actorOf</span><span class="p">(</span><span class="n">Props</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">Swapper</span><span class="p">.</span><span class="n">class</span><span class="p">));</span>
    <span class="n">swap</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">SWAP</span><span class="p">,</span> <span class="n">ActorRef</span><span class="p">.</span><span class="n">noSender</span><span class="p">());</span> <span class="c1">// logs Hi</span>
    <span class="n">swap</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">SWAP</span><span class="p">,</span> <span class="n">ActorRef</span><span class="p">.</span><span class="n">noSender</span><span class="p">());</span> <span class="c1">// logs Ho</span>
    <span class="n">swap</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">SWAP</span><span class="p">,</span> <span class="n">ActorRef</span><span class="p">.</span><span class="n">noSender</span><span class="p">());</span> <span class="c1">// logs Hi</span>
    <span class="n">swap</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">SWAP</span><span class="p">,</span> <span class="n">ActorRef</span><span class="p">.</span><span class="n">noSender</span><span class="p">());</span> <span class="c1">// logs Ho</span>
    <span class="n">swap</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">SWAP</span><span class="p">,</span> <span class="n">ActorRef</span><span class="p">.</span><span class="n">noSender</span><span class="p">());</span> <span class="c1">// logs Hi</span>
    <span class="n">swap</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">SWAP</span><span class="p">,</span> <span class="n">ActorRef</span><span class="p">.</span><span class="n">noSender</span><span class="p">());</span> <span class="c1">// logs Ho</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre></div>

<h2>
<a name="user-content-killing-an-actor" class="anchor" href="#killing-an-actor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Killing an Actor</h2>

<p>You can kill an actor by sending a Kill message. This will cause the actor to throw a ActorKilledException, triggering a failure. The actor will suspend operation and its supervisor will be asked how to handle the failure, which may mean resuming the actor, restarting it or terminating it completely. See What Supervision Means for more information.</p>

<p>Use <code>Kill</code> like this:</p>

<div class="highlight highlight-csharp"><pre><span class="n">victim</span><span class="p">.</span><span class="n">Tell</span><span class="p">(</span><span class="n">Akka</span><span class="p">.</span><span class="n">Actor</span><span class="p">.</span><span class="n">Kill</span><span class="p">.</span><span class="n">Instance</span><span class="p">,</span> <span class="n">ActorRef</span><span class="p">.</span><span class="n">NoSender</span><span class="p">);</span>
</pre></div>

<h2>
<a name="user-content-actors-and-exceptions" class="anchor" href="#actors-and-exceptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Actors and exceptions</h2>

<p>It can happen that while a message is being processed by an actor, that some kind of exception is thrown, e.g. a database exception.</p>

<h3>
<a name="user-content-what-happens-to-the-message" class="anchor" href="#what-happens-to-the-message" aria-hidden="true"><span class="octicon octicon-link"></span></a>What happens to the Message</h3>

<p>If an exception is thrown while a message is being processed (i.e. taken out of its mailbox and handed over to the current behavior), then this message will be lost. It is important to understand that it is not put back on the mailbox. So if you want to retry processing of a message, you need to deal with it yourself by catching the exception and retry your flow. Make sure that you put a bound on the number of retries since you don't want a system to livelock (so consuming a lot of cpu cycles without making progress). Another possibility would be to have a look at the PeekMailbox pattern.</p>

<h3>
<a name="user-content-what-happens-to-the-mailbox" class="anchor" href="#what-happens-to-the-mailbox" aria-hidden="true"><span class="octicon octicon-link"></span></a>What happens to the mailbox</h3>

<p>If an exception is thrown while a message is being processed, nothing happens to the mailbox. If the actor is restarted, the same mailbox will be there. So all messages on that mailbox will be there as well.</p>

<h3>
<a name="user-content-what-happens-to-the-actor" class="anchor" href="#what-happens-to-the-actor" aria-hidden="true"><span class="octicon octicon-link"></span></a>What happens to the actor</h3>

<p>If code within an actor throws an exception, that actor is suspended and the supervision process is started (see Supervision and Monitoring). Depending on the supervisor’s decision the actor is resumed (as if nothing happened), restarted (wiping out its internal state and starting from scratch) or terminated.</p>

<h2>
<a name="user-content-initialization-patterns" class="anchor" href="#initialization-patterns" aria-hidden="true"><span class="octicon octicon-link"></span></a>Initialization patterns</h2>

<p>The rich lifecycle hooks of Actors provide a useful toolkit to implement various initialization patterns. During the lifetime of an ActorRef, an actor can potentially go through several restarts, where the old instance is replaced by a fresh one, invisibly to the outside observer who only sees the ActorRef.</p>

<p>One may think about the new instances as "incarnations". Initialization might be necessary for every incarnation of an actor, but sometimes one needs initialization to happen only at the birth of the first instance when the ActorRef is created. The following sections provide patterns for different initialization needs.</p>

<h3>
<a name="user-content-initialization-via-constructor" class="anchor" href="#initialization-via-constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Initialization via constructor</h3>

<p>Using the constructor for initialization has various benefits. First of all, it makes it possible to use val fields to store any state that does not change during the life of the actor instance, making the implementation of the actor more robust. The constructor is invoked for every incarnation of the actor, therefore the internals of the actor can always assume that proper initialization happened. This is also the drawback of this approach, as there are cases when one would like to avoid reinitializing internals on restart. For example, it is often useful to preserve child actors across restarts. The following section provides a pattern for this case.</p>

<h3>
<a name="user-content-initialization-via-prestart" class="anchor" href="#initialization-via-prestart" aria-hidden="true"><span class="octicon octicon-link"></span></a>Initialization via preStart</h3>

<p>The method preStart() of an actor is only called once directly during the initialization of the first instance, that is, at creation of its ActorRef. In the case of restarts, preStart() is called from postRestart(), therefore if not overridden, preStart() is called on every incarnation. However, overriding postRestart() one can disable this behavior, and ensure that there is only one call to preStart().</p>

<p>One useful usage of this pattern is to disable creation of new ActorRefs for children during restarts. This can be achieved by overriding preRestart():</p>

<div class="highlight highlight-csharp"><pre><span class="n">@Override</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">preStart</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Initialize children here</span>
<span class="p">}</span>

<span class="c1">// Overriding postRestart to disable the call to preStart()</span>
<span class="c1">// after restarts</span>
<span class="n">@Override</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">postRestart</span><span class="p">(</span><span class="n">Throwable</span> <span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">// The default implementation of preRestart() stops all the children</span>
<span class="c1">// of the actor. To opt-out from stopping the children, we</span>
<span class="c1">// have to override preRestart()</span>
<span class="n">@Override</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">preRestart</span><span class="p">(</span><span class="n">Throwable</span> <span class="n">reason</span><span class="p">,</span> <span class="n">Option</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;</span> <span class="n">message</span><span class="p">)</span>
  <span class="n">throws</span> <span class="n">Exception</span> <span class="p">{</span>
  <span class="c1">// Keep the call to postStop(), but no stopping of children</span>
  <span class="n">postStop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p>Please note, that the child actors are still restarted, but no new ActorRef is created. One can recursively apply the same principles for the children, ensuring that their preStart() method is called only at the creation of their refs.</p>

<p>For more information see What Restarting Means.</p>

<h3>
<a name="user-content-initialization-via-message-passing" class="anchor" href="#initialization-via-message-passing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Initialization via message passing</h3>

<p>There are cases when it is impossible to pass all the information needed for actor initialization in the constructor, for example in the presence of circular dependencies. In this case the actor should listen for an initialization message, and use become() or a finite state-machine state transition to encode the initialized and uninitialized states of the actor.</p>

<div class="highlight highlight-csharp"><pre><span class="k">private</span> <span class="n">String</span> <span class="n">initializeMe</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

<span class="n">@Override</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">onReceive</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Exception</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="s">"init"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">initializeMe</span> <span class="p">=</span> <span class="s">"Up and running"</span><span class="p">;</span>
    <span class="n">getContext</span><span class="p">().</span><span class="n">become</span><span class="p">(</span><span class="k">new</span> <span class="n">Procedure</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;()</span> <span class="p">{</span>
      <span class="n">@Override</span>
      <span class="k">public</span> <span class="k">void</span> <span class="nf">apply</span><span class="p">(</span><span class="n">Object</span> <span class="n">message</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Exception</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="k">equals</span><span class="p">(</span><span class="s">"U OK?"</span><span class="p">))</span>
          <span class="n">getSender</span><span class="p">().</span><span class="n">tell</span><span class="p">(</span><span class="n">initializeMe</span><span class="p">,</span> <span class="n">getSelf</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>If the actor may receive messages before it has been initialized, a useful tool can be the Stash to save messages until the initialization finishes, and replaying them after the actor became initialized.</p>

<blockquote>
<p><strong>Warning</strong><br>
This pattern should be used with care, and applied only when none of the patterns above are applicable. One of the potential issues is that messages might be lost when sent to remote actors. Also, publishing an ActorRef in an uninitialized state might lead to the condition that it receives a user message before the initialization has been done.</p>
</blockquote>
    
                <div id="disqus_thread"></div>
                <script type="text/javascript">
                    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                    var disqus_shortname = 'akkanet'; // required: replace example with your forum shortname

                    /* * * DON'T EDIT BELOW THIS LINE * * */
                    (function () {
                        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                    })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            </div>
            <div class="span3">
                 <a href="index.html">
                <img src="content/akkanet.png" style="width:140px;height:140px;margin:10px 0px 0px 35px;border-style:none;border-radius:10px;" />
                </a>
                <ul class="nav nav-list" id="menu">
                    <li class="nav-header">Table of contents</li>
                    <li><a href="index.html">Home page</a></li>
                    <li class="divider"></li>
                    
          <h4>
<a name="user-content-introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h4>

<ul class="task-list">
<li><a href="What-is-Akka">What is Akka?</a></li>
<li><a href="Why-Akka">Why Akka?</a></li>
<li><a href="Getting-started">Getting Started</a></li>
<li><a href="The-Obligatory-Hello-World">The Obligatory Hello World</a></li>
<li><a href="Use-case-and-Deployment-Scenarios">Use-case and Deployment Scenarios</a></li>
<li><a href="Examples-of-use-cases-for-Akka">Examples of use-cases for Akka</a></li>
</ul><hr><h4>
<a name="user-content-general" class="anchor" href="#general" aria-hidden="true"><span class="octicon octicon-link"></span></a>General</h4>

<ul class="task-list">
<li><a href="Terminology">Terminology, Concepts</a></li>
<li><a href="Actor-Systems">Actor Systems</a></li>
<li><a href="Actors">What is an Actor?</a></li>
<li><a href="Supervision">Supervision and Monitoring</a></li>
<li><a href="Addressing">Actor References, Paths and Addresses</a></li>
<li><a href="Remoting">Location Transparency</a></li>
<li>Akka and the Java Memory Model</li>
<li><a href="Message-Delivery-Reliability">Message Delivery Reliability</a></li>
<li><a href="Configuration">Configuration</a></li>
</ul><hr><h4>
<a name="user-content-actors" class="anchor" href="#actors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Actors</h4>

<ul class="task-list">
<li><a class="internal present" href="Actors">Actors</a></li>
<li><a class="internal present" href="C%23-actors">C# Actors</a></li>
<li><a class="internal present" href="F%23-Actors">F# Actors</a></li>
<li>Typed Actors</li>
<li><a href="FSM">Finite State Machines</a></li>
<li>Fault Tolerance</li>
<li><a class="internal present" href="Dispatchers">Dispatchers</a></li>
<li><a class="internal present" href="Mailboxes">Mailboxes</a></li>
<li><a class="internal present" href="Routing">Routing</a></li>
<li><a class="internal present" href="Actor-lifecycle">Actor lifecycle</a></li>
<li><a class="internal present" href="Props">Props</a></li>
<li><a class="internal present" href="Receive-timeout">Receive timeout</a></li>
<li><a class="internal present" href="Dependency-injection">Dependency injection</a></li>
<li><a class="internal present" href="Stash">Stash</a></li>
<li>Persistence (Not ported to Akka.NET yet)</li>
<li>Testing Actor Systems</li>
</ul><hr><h4>
<a name="user-content-networking" class="anchor" href="#networking" aria-hidden="true"><span class="octicon octicon-link"></span></a>Networking</h4>

<ul class="task-list">
<li>Cluster Specification (Not ported to Akka.NET yet)</li>
<li>Cluster Usage (Not ported to Akka.NET yet)</li>
<li><a class="internal present" href="Remoting">Remoting</a></li>
<li><a class="internal present" href="Serialization">Serialization</a></li>
<li>I/O (Not ported to Akka.NET yet)</li>
<li>Using TCP</li>
<li>Using UDP</li>
</ul><hr><h4>
<a name="user-content-utilities" class="anchor" href="#utilities" aria-hidden="true"><span class="octicon octicon-link"></span></a>Utilities</h4>

<ul class="task-list">
<li><a class="internal present" href="EventBus">EventBus</a></li>
<li><a class="internal present" href="Logging">Logging</a></li>
<li><a class="internal present" href="Scheduler">Scheduler</a></li>
<li><a class="internal present" href="Circuit-Breaker">Circuit Breaker</a></li>
</ul><hr><h4>
<a name="user-content-howto-common-patterns" class="anchor" href="#howto-common-patterns" aria-hidden="true"><span class="octicon octicon-link"></span></a>HowTo: Common Patterns</h4>

<ul class="task-list">
<li><a class="internal present" href="Scheduling-Periodic-Messages">Scheduling Periodic Messages</a></li>
<li><a class="internal absent" href="Single-Use-Actor-Trees-with-High-Level-Error-Reporting">Single-Use Actor Trees with High-Level Error Reporting</a></li>
</ul><hr><h4>
<a name="user-content-experimental-modules" class="anchor" href="#experimental-modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Experimental Modules</h4>

<ul class="task-list">
<li>
<a class="internal absent" href="Persistence">Persistence</a>(Not ported to Akka.NET yet)</li>
<li><a class="internal absent" href="Multi-Node-Testing">Multi Node Testing</a></li>
</ul><hr><h4>
<a name="user-content-information-for-akka-developers" class="anchor" href="#information-for-akka-developers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Information for Akka Developers</h4>

<ul class="task-list">
<li><a class="internal present" href="Building-and-Distributing-Akka.NET">Building and Distributing Akka.NET</a></li>
<li><a class="internal present" href="Developer-Guidelines">Developer Guidelines</a></li>
<li><a class="internal absent" href="Documentation-Guidelines">Documentation Guidelines</a></li>
<li><a class="internal present" href="Team">Team</a></li>
</ul><hr><h4>
<a name="user-content-project-information" class="anchor" href="#project-information" aria-hidden="true"><span class="octicon octicon-link"></span></a>Project Information</h4>

<ul class="task-list">
<li><a href="https://github.com/akkadotnet/akka.net/issues?state=open">Issue Tracking</a></li>
<li><a class="internal present" href="Licenses">Licenses</a></li>
<li><a class="internal present" href="Sponsors">Sponsors</a></li>
<li><a class="internal present" href="Project">Project</a></li>
</ul><hr><h4>
<a name="user-content-additional-information" class="anchor" href="#additional-information" aria-hidden="true"><span class="octicon octicon-link"></span></a>Additional Information</h4>

<ul class="task-list">
<li><a class="internal present" href="Frequently-Asked-Questions">Frequently Asked Questions</a></li>
<li><a class="internal present" href="Books">Books</a></li>
</ul>
        
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="span12" id="forum">
                
            </div>
        </div>
    </div>
    <a href="https://github.com/akkadotnet/Akka.NET"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>   
</body>
</html>